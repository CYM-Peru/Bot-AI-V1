/**
 * PostgreSQL Database Layer for CRM
 * Provides same interface as db.ts but uses PostgreSQL
 */
import { Pool } from 'pg';
import type { Conversation, Message, Attachment } from './models';

const pool = new Pool({
  user: 'postgres',
  host: 'localhost',
  database: 'flowbuilder_crm',
  password: 'flowbuilder2025',
  port: 5432,
  max: 20,
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 2000,
});

export class PostgresCRMDatabase {
  
  // ==================== CONVERSATIONS ====================
  
  getConversationById(id: string): Conversation | null {
    // TODO: Implement async version
    return null;
  }

  async getConversationByIdAsync(id: string): Promise<Conversation | null> {
    try {
      const result = await pool.query(
        'SELECT * FROM crm_conversations WHERE id = $1',
        [id]
      );
      
      if (result.rows.length === 0) return null;
      
      return this.rowToConversation(result.rows[0]);
    } catch (error) {
      console.error('[PostgresCRM] Error getting conversation:', error);
      return null;
    }
  }

  async getConversationByPhoneAndChannel(
    phone: string,
    channel: string = 'whatsapp',
    phoneNumberId?: string | null
  ): Promise<Conversation | null> {
    try {
      let query = 'SELECT * FROM crm_conversations WHERE phone = $1 AND channel = $2';
      const params: any[] = [phone, channel];

      if (phoneNumberId) {
        query += ' AND phone_number_id = $3';
        params.push(phoneNumberId);
      }

      const result = await pool.query(query, params);
      
      if (result.rows.length === 0) return null;
      
      return this.rowToConversation(result.rows[0]);
    } catch (error) {
      console.error('[PostgresCRM] Error getting conversation by phone:', error);
      return null;
    }
  }

  async createConversation(
    phone: string,
    contactName: string | null = null,
    avatarUrl: string | null = null,
    channel: string = 'whatsapp',
    phoneNumberId?: string | null,
    displayNumber?: string | null
  ): Promise<Conversation> {
    const { randomUUID } = await import('crypto');
    const id = randomUUID();
    const now = Date.now();

    const conv: Conversation = {
      id,
      phone,
      contactName,
      bitrixId: null,
      bitrixDocument: null,
      avatarUrl,
      lastMessageAt: now,
      unread: 0,
      status: 'active',
      lastMessagePreview: '',
      assignedTo: null,
      assignedAt: null,
      queuedAt: null,
      queueId: null,
      channel,
      channelConnectionId: phoneNumberId || null,
      phoneNumberId: phoneNumberId || null,
      displayNumber: displayNumber || null,
      attendedBy: [],
      ticketNumber: await this.getNextTicketNumber(),
      botStartedAt: null,
      botFlowId: null,
      readAt: null,
      transferredFrom: null,
      transferredAt: null,
      activeAdvisors: [],
    };

    try {
      await pool.query(`
        INSERT INTO crm_conversations (
          id, phone, contact_name, avatar_url, last_message_at, unread, status,
          channel, channel_connection_id, phone_number_id, display_number,
          attended_by, ticket_number, active_advisors, created_at, updated_at
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
      `, [
        conv.id, conv.phone, conv.contactName, conv.avatarUrl, conv.lastMessageAt,
        conv.unread, conv.status, conv.channel, conv.channelConnectionId,
        conv.phoneNumberId, conv.displayNumber, JSON.stringify(conv.attendedBy),
        conv.ticketNumber, JSON.stringify(conv.activeAdvisors), now, now
      ]);

      return conv;
    } catch (error) {
      console.error('[PostgresCRM] Error creating conversation:', error);
      throw error;
    }
  }

  async appendMessage(data: {
    convId: string;
    direction: 'incoming' | 'outgoing';
    type: string;
    text: string | null;
    mediaUrl?: string | null;
    mediaThumb?: string | null;
    repliedToId?: string | null;
    status?: string;
  }): Promise<Message> {
    const { randomUUID } = await import('crypto');
    const id = randomUUID();
    const now = Date.now();

    const message: Message = {
      id,
      conversationId: data.convId,
      direction: data.direction,
      type: data.type || 'text',
      text: data.text,
      mediaUrl: data.mediaUrl || null,
      mediaThumb: data.mediaThumb || null,
      repliedToId: data.repliedToId || null,
      status: data.status || 'sent',
      createdAt: now,
      providerMetadata: null,
    };

    try {
      await pool.query(`
        INSERT INTO crm_messages (
          id, conversation_id, direction, type, text, media_url,
          media_thumb, replied_to_id, status, timestamp, created_at
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
      `, [
        message.id, message.conversationId, message.direction, message.type,
        message.text, message.mediaUrl, message.mediaThumb, message.repliedToId,
        message.status, now, now
      ]);

      // Update conversation's last message
      await pool.query(`
        UPDATE crm_conversations 
        SET last_message_at = $1, 
            last_message_preview = $2,
            updated_at = $3
        WHERE id = $4
      `, [now, message.text?.substring(0, 100) || '', now, data.convId]);

      return message;
    } catch (error) {
      console.error('[PostgresCRM] Error appending message:', error);
      throw error;
    }
  }

  async getAllConversations(): Promise<Conversation[]> {
    try {
      const result = await pool.query(
        'SELECT * FROM crm_conversations ORDER BY last_message_at DESC'
      );
      
      return result.rows.map(row => this.rowToConversation(row));
    } catch (error) {
      console.error('[PostgresCRM] Error getting all conversations:', error);
      return [];
    }
  }

  async listMessages(conversationId: string): Promise<Message[]> {
    try {
      const result = await pool.query(
        'SELECT * FROM crm_messages WHERE conversation_id = $1 ORDER BY timestamp ASC',
        [conversationId]
      );
      
      return result.rows.map(row => this.rowToMessage(row));
    } catch (error) {
      console.error('[PostgresCRM] Error listing messages:', error);
      return [];
    }
  }

  // Helper: Convert DB row to Conversation object
  private rowToConversation(row: any): Conversation {
    return {
      id: row.id,
      phone: row.phone,
      contactName: row.contact_name,
      bitrixId: row.bitrix_id,
      bitrixDocument: row.bitrix_document,
      avatarUrl: row.avatar_url,
      lastMessageAt: parseInt(row.last_message_at),
      unread: row.unread,
      status: row.status,
      lastMessagePreview: row.last_message_preview,
      assignedTo: row.assigned_to,
      assignedAt: row.assigned_at ? parseInt(row.assigned_at) : null,
      queuedAt: row.queued_at ? parseInt(row.queued_at) : null,
      queueId: row.queue_id,
      channel: row.channel,
      channelConnectionId: row.channel_connection_id,
      phoneNumberId: row.phone_number_id,
      displayNumber: row.display_number,
      attendedBy: row.attended_by || [],
      ticketNumber: row.ticket_number,
      botStartedAt: row.bot_started_at ? parseInt(row.bot_started_at) : null,
      botFlowId: row.bot_flow_id,
      readAt: row.read_at ? parseInt(row.read_at) : null,
      transferredFrom: row.transferred_from,
      transferredAt: row.transferred_at ? parseInt(row.transferred_at) : null,
      activeAdvisors: row.active_advisors || [],
    };
  }

  // Helper: Convert DB row to Message object
  private rowToMessage(row: any): Message {
    return {
      id: row.id,
      conversationId: row.conversation_id,
      direction: row.direction,
      type: row.type,
      text: row.text,
      mediaUrl: row.media_url,
      mediaThumb: row.media_thumb,
      repliedToId: row.replied_to_id,
      status: row.status,
      createdAt: parseInt(row.timestamp),
      providerMetadata: row.metadata,
    };
  }

  // Helper: Get next ticket number
  private async getNextTicketNumber(): Promise<number> {
    try {
      const result = await pool.query(
        'SELECT COALESCE(MAX(ticket_number), 0) + 1 as next FROM crm_conversations'
      );
      return result.rows[0].next;
    } catch (error) {
      console.error('[PostgresCRM] Error getting next ticket number:', error);
      return 1;
    }
  }
}

export const postgresCrmDb = new PostgresCRMDatabase();
