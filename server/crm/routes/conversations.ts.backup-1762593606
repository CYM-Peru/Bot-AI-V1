import { Router } from "express";
import { crmDb } from "../db";
import { metricsTracker } from "../metrics-tracker";
import type { CrmRealtimeManager } from "../ws";
import type { BitrixService } from "../services/bitrix";
import { adminDb } from "../../admin-db";
import type { LocalStorageFlowProvider } from "../../flow-provider";
import { sessionsStorage } from "../sessions";

// Helper function to get advisor name from ID
async function getAdvisorName(advisorId: string): Promise<string> {
  try {
    const user = adminDb.getUserById(advisorId);
    return user?.name || user?.username || advisorId;
  } catch (error) {
    console.error("[CRM] Error getting advisor name:", error);
    return advisorId;
  }
}

// Helper function to get bot/flow name from ID
async function getBotName(botId: string, flowProvider: LocalStorageFlowProvider): Promise<string> {
  try {
    const flow = await flowProvider.getFlow(botId);
    return flow?.name || botId;
  } catch (error) {
    console.error("[CRM] Error getting bot name:", error);
    return botId;
  }
}

export function createConversationsRouter(socketManager: CrmRealtimeManager, bitrixService: BitrixService, flowProvider: LocalStorageFlowProvider) {
  const router = Router();

  router.get("/", async (_req, res) => {
    const conversations = await crmDb.listConversations();
    res.json(
      conversations.map((conversation) => ({
        id: conversation.id,
        phone: conversation.phone,
        contactName: conversation.contactName ?? null,
        lastMessageAt: conversation.lastMessageAt,
        lastMessagePreview: conversation.lastMessagePreview ?? null,
        unread: conversation.unread,
        status: conversation.status,
        bitrixId: conversation.bitrixId ?? null,
        bitrixDocument: conversation.bitrixDocument ?? null,
        avatarUrl: conversation.avatarUrl ?? null,
        assignedTo: conversation.assignedTo ?? null,
        assignedAt: conversation.assignedAt ?? null,
        queuedAt: conversation.queuedAt ?? null,
        queueId: conversation.queueId ?? null,
        channel: conversation.channel ?? "whatsapp",
        channelConnectionId: conversation.channelConnectionId ?? null,
        displayNumber: conversation.displayNumber ?? null,
        attendedBy: conversation.attendedBy ?? null,
        ticketNumber: conversation.ticketNumber ?? null,
      })),
    );
  });

  router.get("/:id/messages", async (req, res) => {
    const conversation = await crmDb.getConversationById(req.params.id);
    if (!conversation) {
      res.status(404).json({ error: "not_found" });
      return;
    }
    const messages = await crmDb.listMessages(conversation.id);
    const attachments = await crmDb.listAttachmentsByMessageIds(messages.map((message) => message.id));
    res.json({ messages, attachments });
  });

  router.post("/:id/mark-read", async (req, res) => {
    const conversation = await crmDb.getConversationById(req.params.id);
    if (!conversation) {
      res.status(404).json({ error: "not_found" });
      return;
    }

    await crmDb.markConversationRead(conversation.id);
    const updated = await crmDb.getConversationById(conversation.id);
    if (updated) {
      socketManager.emitConversationUpdate({ conversation: updated });
    }

    res.json({ success: true });
  });

  router.get("/:id/bitrix", async (req, res) => {
    const conversation = crmDb.getConversationById(req.params.id);
    if (!conversation) {
      res.status(404).json({ error: "not_found" });
      return;
    }
    if (!bitrixService.isAvailable) {
      res.json({ contact: null, bitrixId: conversation.bitrixId, status: "bitrix_not_configured" });
      return;
    }
    try {
      let contact = conversation.bitrixId ? await bitrixService.fetchContact(conversation.bitrixId) : null;
      if (!contact) {
        contact = await bitrixService.lookupByPhone(conversation.phone);
        if (contact?.ID) {
          bitrixService.attachConversation(conversation, contact.ID.toString());
        }
      }

      // IMPORTANTE: Sincronizar nombre del contacto desde Bitrix
      if (contact && (contact.NAME || contact.LAST_NAME)) {
        const fullName = [contact.NAME, contact.LAST_NAME].filter(Boolean).join(" ").trim();
        if (fullName && fullName !== conversation.contactName) {
          crmDb.updateConversationMeta(conversation.id, { contactName: fullName });
          console.log(`[CRM] âœ… Nombre sincronizado desde Bitrix: ${fullName} para conversaciÃ³n ${conversation.id}`);
        }
      }

      res.json({ contact, bitrixId: contact?.ID ?? conversation.bitrixId ?? null });
    } catch (error) {
      console.error("[CRM] bitrix fetch error", error);
      res.status(500).json({ error: "bitrix_lookup_failed" });
    }
  });

  /**
   * POST /:id/bitrix/create
   * Crea manualmente un contacto/lead en Bitrix24 desde el CRM
   */
  router.post("/:id/bitrix/create", async (req, res) => {
    const conversation = crmDb.getConversationById(req.params.id);
    if (!conversation) {
      res.status(404).json({ error: "not_found" });
      return;
    }
    if (!bitrixService.isAvailable) {
      res.status(503).json({ error: "bitrix_not_configured" });
      return;
    }
    try {
      const { phone, name } = req.body;
      const result = await bitrixService.createContactWithCustomFields({
        phone: phone || conversation.phone,
        profileName: name || conversation.contactName || undefined,
      });

      if (result.contactId) {
        bitrixService.attachConversation(conversation, result.contactId);
        const contact = await bitrixService.fetchContact(result.contactId);

        // IMPORTANTE: Sincronizar nombre del contacto desde Bitrix
        if (contact && (contact.NAME || contact.LAST_NAME)) {
          const fullName = [contact.NAME, contact.LAST_NAME].filter(Boolean).join(" ").trim();
          if (fullName && fullName !== conversation.contactName) {
            crmDb.updateConversationMeta(conversation.id, { contactName: fullName });
            console.log(`[CRM] âœ… Nombre sincronizado desde Bitrix (creado): ${fullName} para conversaciÃ³n ${conversation.id}`);
          }
        }

        res.json({ success: true, contact, bitrixId: result.contactId, entityType: result.entityType });
      } else {
        res.status(500).json({ error: "create_failed", reason: result.reason });
      }
    } catch (error) {
      console.error("[CRM] bitrix create error", error);
      res.status(500).json({ error: "bitrix_create_failed" });
    }
  });

  router.post("/:id/archive", async (req, res) => {
    const conversation = await crmDb.getConversationById(req.params.id);
    if (!conversation) {
      res.status(404).json({ error: "not_found" });
      return;
    }

    // Create system message for archiving
    const archiveMessage = await crmDb.appendMessage({
      convId: conversation.id,
      direction: "outgoing",
      type: "system",
      text: `ðŸ“ ConversaciÃ³n cerrada`,
      mediaUrl: null,
      mediaThumb: null,
      repliedToId: null,
      status: "sent",
    });

    // Emit the system message via WebSocket
    socketManager.emitNewMessage({ message: archiveMessage, attachment: null });

    await crmDb.archiveConversation(conversation.id);

    // End metrics tracking for this conversation with 'completed' status
    metricsTracker.endConversation(conversation.id, 'completed');

    const updated = await crmDb.getConversationById(conversation.id);
    if (updated) {
      socketManager.emitConversationUpdate({ conversation: updated });
    }
    res.json({ success: true });
  });

  router.post("/:id/unarchive", async (req, res) => {
    const conversation = await crmDb.getConversationById(req.params.id);
    if (!conversation) {
      res.status(404).json({ error: "not_found" });
      return;
    }
    // Cambiar el estado a "active" para desarchivar
    await crmDb.updateConversationMeta(conversation.id, { status: "active" });
    const updated = await crmDb.getConversationById(conversation.id);
    if (updated) {
      socketManager.emitConversationUpdate({ conversation: updated });
    }
    res.json({ success: true });
  });

  router.post("/:id/transfer", async (req, res) => {
    const conversation = await crmDb.getConversationById(req.params.id);
    if (!conversation) {
      res.status(404).json({ error: "not_found" });
      return;
    }

    const { type, targetId } = req.body;

    if (!type || !targetId) {
      res.status(400).json({ error: "missing_parameters" });
      return;
    }

    if (type !== "advisor" && type !== "bot") {
      res.status(400).json({ error: "invalid_type" });
      return;
    }

    // Get current advisor info (who is transferring)
    const currentAdvisorId = req.user?.userId || "unknown";
    const currentAdvisorName = await getAdvisorName(currentAdvisorId);

    // Update conversation metadata with transfer info
    const metadata = conversation.metadata || {};
    metadata.transferredTo = targetId;
    metadata.transferType = type;
    metadata.transferredAt = Date.now();

    // Get display names for system message
    let displayName = targetId;
    if (type === "advisor") {
      displayName = await getAdvisorName(targetId);

      // CRITICAL: Check advisor status before transferring
      const advisorStatus = adminDb.getAdvisorStatus(targetId);
      if (advisorStatus) {
        const statusDetails = adminDb.getAdvisorStatusById(advisorStatus.statusId);
        if (statusDetails && statusDetails.action !== "accept") {
          // Advisor is not accepting chats
          res.status(400).json({
            error: "advisor_not_available",
            message: `El asesor ${displayName} no puede recibir conversaciones en este momento (Estado: ${statusDetails.name})`,
            advisorName: displayName,
            statusName: statusDetails.name
          });
          return;
        }
      }

      // CRITICAL: If transferring to an advisor, assign the conversation directly
      crmDb.updateConversationMeta(conversation.id, {
        assignedTo: targetId,
        assignedAt: Date.now(),
        // Status remains "active" - will change to "attending" when advisor sends first message
      });
      // Add advisor to attendedBy list
      crmDb.addAdvisorToAttendedBy(conversation.id, targetId);
      console.log(`[CRM] âœ… Conversation ${conversation.id} transferred to advisor: ${displayName} (${targetId}) (awaiting response)`);
    } else {
      displayName = await getBotName(targetId, flowProvider);
      // For bot transfers, just update metadata
      console.log(`[CRM] âœ… Conversation ${conversation.id} transferred to bot: ${displayName} (${targetId})`);
    }

    // Create system message for the transfer
    const transferMessage = await crmDb.appendMessage({
      convId: conversation.id,
      direction: "outgoing",
      type: "system",
      text: type === "advisor"
        ? `ðŸ”€ ConversaciÃ³n transferida de ${currentAdvisorName} a ${displayName}`
        : `ðŸ¤– ConversaciÃ³n transferida de ${currentAdvisorName} a bot ${displayName}`,
      mediaUrl: null,
      mediaThumb: null,
      repliedToId: null,
      status: "sent",
    });

    // Emit the system message via WebSocket
    socketManager.emitNewMessage({ message: transferMessage, attachment: null });

    // Track conversation transfer in metrics (only for advisor transfers)
    // This will create TWO metrics: transfer_out (current advisor) and transfer_in (receiving advisor)
    if (type === "advisor") {
      metricsTracker.transferConversation(conversation.id, currentAdvisorId, targetId, {
        queueId: conversation.queueId || undefined,
        channelType: conversation.channel as any,
        channelId: conversation.channelConnectionId || undefined,
      });
    }

    // Optionally archive the conversation after transfer
    // crmDb.archiveConversation(conversation.id);

    const updated = crmDb.getConversationById(conversation.id);
    if (updated) {
      socketManager.emitConversationUpdate({ conversation: updated });
    }

    res.json({ success: true, transferred: { type, targetId } });
  });

  // Queue management endpoints
  router.get("/queue", (_req, res) => {
    const queuedConversations = crmDb.listQueuedConversations();
    res.json({ conversations: queuedConversations });
  });

  router.post("/:id/accept", async (req, res) => {
    const conversation = await crmDb.getConversationById(req.params.id);
    if (!conversation) {
      res.status(404).json({ error: "not_found" });
      return;
    }

    // Get advisor ID from auth (user ID)
    const advisorId = req.user?.userId || "unknown";

    const accepted = crmDb.acceptConversation(conversation.id, advisorId);
    if (!accepted) {
      res.status(400).json({ error: "cannot_accept", reason: "Conversation is not in queue" });
      return;
    }

    // Start tracking metrics for this conversation with full context
    metricsTracker.startConversation(conversation.id, advisorId, {
      queueId: conversation.queueId || undefined,
      channelType: conversation.channel as any,
      channelId: conversation.channelConnectionId || undefined,
    });

    // Get advisor display name
    const advisorName = await getAdvisorName(advisorId);

    // Create system message for accepting the conversation
    const acceptMessage = await crmDb.appendMessage({
      convId: conversation.id,
      direction: "outgoing",
      type: "system",
      text: `âœ… ConversaciÃ³n aceptada por ${advisorName}`,
      mediaUrl: null,
      mediaThumb: null,
      repliedToId: null,
      status: "sent",
    });

    // Emit the system message via WebSocket
    socketManager.emitNewMessage({ message: acceptMessage, attachment: null });

    // Start a session for this conversation
    try {
      const session = await sessionsStorage.startSession(advisorId, conversation.id);
      console.log(`[CRM] Session started: ${session.id} for advisor ${advisorId}`);
    } catch (error) {
      console.error('[CRM] Error starting session:', error);
    }

    const updated = crmDb.getConversationById(conversation.id);
    if (updated) {
      socketManager.emitConversationUpdate({ conversation: updated });
    }

    res.json({ success: true, conversation: updated });
  });

  // Reject conversation (return to queue)
  router.post("/:id/reject", async (req, res) => {
    const conversation = await crmDb.getConversationById(req.params.id);
    if (!conversation) {
      res.status(404).json({ error: "not_found" });
      return;
    }

    const advisorId = req.user?.userId || "unknown";
    const advisorName = await getAdvisorName(advisorId);

    const released = crmDb.releaseConversation(conversation.id);
    if (!released) {
      res.status(400).json({ error: "cannot_reject", reason: "Conversation is not being attended" });
      return;
    }

    // Create system message for rejecting/returning to queue
    const rejectMessage = await crmDb.appendMessage({
      convId: conversation.id,
      direction: "outgoing",
      type: "system",
      text: `âš ï¸ ConversaciÃ³n devuelta a la cola por ${advisorName}`,
      mediaUrl: null,
      mediaThumb: null,
      repliedToId: null,
      status: "sent",
    });

    socketManager.emitNewMessage({ message: rejectMessage, attachment: null });

    // Track conversation rejection in metrics
    const reason = req.body.reason || "Advisor returned conversation to queue";
    metricsTracker.rejectConversation(conversation.id, advisorId, reason);

    const updated = crmDb.getConversationById(conversation.id);
    if (updated) {
      socketManager.emitConversationUpdate({ conversation: updated });
    }

    res.json({ success: true, conversation: updated });
  });

  router.post("/:id/release", (req, res) => {
    const conversation = crmDb.getConversationById(req.params.id);
    if (!conversation) {
      res.status(404).json({ error: "not_found" });
      return;
    }

    const released = crmDb.releaseConversation(conversation.id);
    if (!released) {
      res.status(400).json({ error: "cannot_release", reason: "Conversation is not being attended" });
      return;
    }

    const updated = crmDb.getConversationById(conversation.id);
    if (updated) {
      socketManager.emitConversationUpdate({ conversation: updated });
    }

    res.json({ success: true, conversation: updated });
  });

  return router;
}
