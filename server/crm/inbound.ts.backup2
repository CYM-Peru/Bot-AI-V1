import type { ChangeValue, WhatsAppMessage } from "../../src/api/whatsapp-webhook";
import { postgresCrmDb as crmDb } from "./db-postgres";
import { metricsTracker } from "./metrics-tracker";
import type { CrmRealtimeManager } from "./ws";
import type { BitrixService } from "./services/bitrix";
import { attachmentStorage } from "./storage";
import type { Attachment, MessageType } from "./models";
import { logDebug, logError } from "../utils/file-logger";
import { getWhatsAppEnv } from "../utils/env";
import { getCachedProfilePicture } from "../services/whatsapp-profile";
import axios from "axios";
import fs from "fs/promises";
import path from "path";

/**
 * Update connection with WABA ID from webhook
 * This automatically captures the WhatsApp Business Account ID from incoming webhooks
 */
async function updateConnectionWabaId(phoneNumberId: string, wabaId: string): Promise<void> {
  try {
    const connectionsPath = path.join(process.cwd(), "data", "whatsapp-connections.json");
    const data = await fs.readFile(connectionsPath, "utf-8");
    const parsed = JSON.parse(data);

    if (!parsed.connections) {
      return;
    }

    // Find connection by phoneNumberId
    const connection = parsed.connections.find((c: any) => c.phoneNumberId === phoneNumberId);

    if (connection && !connection.wabaId) {
      connection.wabaId = wabaId;
      await fs.writeFile(connectionsPath, JSON.stringify(parsed, null, 2), "utf-8");
      logDebug(`[CRM] Updated connection ${connection.id} with WABA ID: ${wabaId}`);
    }
  } catch (error) {
    logError(`[CRM] Failed to update connection with WABA ID:`, error);
  }
}

interface HandleIncomingArgs {
  entryId: string;
  value: ChangeValue;
  message: WhatsAppMessage;
  socketManager: CrmRealtimeManager;
  bitrixService: BitrixService;
}

export async function handleIncomingWhatsAppMessage(args: HandleIncomingArgs): Promise<void> {
  const phone = args.message.from;
  if (!phone) {
    return;
  }

  // CRITICAL: Extract phoneNumberId and displayNumber from webhook metadata
  // This ensures conversations from different WhatsApp numbers stay separate
  const phoneNumberId = args.value.metadata?.phone_number_id || null;
  const displayNumber = args.value.metadata?.display_phone_number || null;
  const wabaId = args.entryId; // WhatsApp Business Account ID from webhook entry

  logDebug(`[CRM] Incoming message from ${phone} via phoneNumberId: ${phoneNumberId} (${displayNumber}), WABA: ${wabaId}`);

  // Update connection with WABA ID if not already set
  if (phoneNumberId && wabaId) {
    await updateConnectionWabaId(phoneNumberId, wabaId);
  }

  // Get or create conversation using phone + channel + phoneNumberId
  let conversation = await crmDb.getConversationByPhoneAndChannel(phone, "whatsapp", phoneNumberId);
  if (!conversation) {
    // Try to get WhatsApp profile picture
    let avatarUrl: string | null = null;
    try {
      const whatsappEnv = getWhatsAppEnv();
      if (whatsappEnv.accessToken && phoneNumberId) {
        avatarUrl = await getCachedProfilePicture({
          accessToken: whatsappEnv.accessToken,
          phoneNumberId: phoneNumberId,
          apiVersion: whatsappEnv.apiVersion,
          baseUrl: whatsappEnv.baseUrl
        }, phone);
      }
    } catch (error) {
      logError(`[CRM] Failed to fetch profile picture for ${phone}:`, error);
    }

    conversation = await crmDb.createConversation(phone, null, avatarUrl, "whatsapp", phoneNumberId, displayNumber);
    logDebug(`[CRM] Created new conversation ${conversation.id} for ${phone} on WhatsApp ${displayNumber}${avatarUrl ? ' (with profile picture)' : ''}`);

    // CRITICAL: Assign bot and queue to new conversations
    const { adminDb } = await import('../admin-db');

    // 1. Assign bot to conversation initially
    const allUsers = adminDb.getAllUsers();
    const botUser = allUsers.find(u => u.role === "bot" && u.phoneNumberId === phoneNumberId);

    if (botUser) {
      crmDb.assignConversation(conversation.id, botUser.id);
      conversation = crmDb.getConversationById(conversation.id)!;
      logDebug(`[CRM] ü§ñ Bot assigned: ${botUser.name} to conversation ${conversation.id}`);
    } else {
      logDebug(`[CRM] ‚ö†Ô∏è No bot found for phoneNumberId: ${phoneNumberId}`);
    }

    // 2. Auto-assign to first active queue
    const activeQueues = adminDb.getAllQueues().filter(q => q.status === "active");

    if (activeQueues.length > 0) {
      const firstQueue = activeQueues[0];
      crmDb.updateConversationMeta(conversation.id, { queueId: firstQueue.id });
      conversation = crmDb.getConversationById(conversation.id)!;

      logDebug(`[CRM] üéØ New chat auto-assigned to queue: ${firstQueue.name} (${firstQueue.id})`);

      // Try to immediately assign to an available online advisor in the queue
      const { advisorPresence } = await import('./advisor-presence');
      for (const advisorId of firstQueue.assignedAdvisors) {
        const statusAssignment = adminDb.getAdvisorStatus(advisorId);
        if (statusAssignment) {
          const status = adminDb.getAdvisorStatusById(statusAssignment.statusId);
          const presence = advisorPresence.getPresence(advisorId);
          if (presence?.isOnline && status?.action === "accept") {
            crmDb.assignConversation(conversation.id, advisorId);
            conversation = crmDb.getConversationById(conversation.id)!;

            const user = adminDb.getUserById(advisorId);
            const advisorName = user?.username || advisorId;
            logDebug(`[CRM] ‚úÖ New chat auto-assigned to online advisor: ${advisorName}`);

            crmDb.appendMessage({
              convId: conversation.id,
              direction: "outgoing",
              type: "system",
              text: `üéØ Chat nuevo - Asignado autom√°ticamente a: ${advisorName}`,
              mediaUrl: null,
              mediaThumb: null,
              repliedToId: null,
              status: "sent",
            });
            break;
          }
        }
      }
    } else {
      logDebug(`[CRM] ‚ö†Ô∏è No active queues found - chat ${conversation.id} not assigned to queue`);
    }
  }

  // Auto-unarchive if client writes back
  if (conversation.status === "archived") {
    crmDb.updateConversationMeta(conversation.id, { status: "active" });
    conversation = crmDb.getConversationById(conversation.id)!;
    logDebug(`[CRM] Conversaci√≥n ${conversation.id} auto-desarchivada al recibir mensaje`);
  }

  // Auto-reassign to last advisor if conversation has history but no current assignment
  // CRITICAL: When a client writes back, reassign to the advisor who attended them before
  if (conversation.status === "active" &&
      !conversation.assignedTo &&
      conversation.attendedBy &&
      conversation.attendedBy.length > 0 &&
      !conversation.transferredFrom) {

    const lastAdvisorId = conversation.attendedBy[conversation.attendedBy.length - 1];
    crmDb.assignConversation(conversation.id, lastAdvisorId);
    conversation = crmDb.getConversationById(conversation.id)!;

    logDebug(`[CRM] Cliente recurrente: auto-asignado a √∫ltimo asesor ${lastAdvisorId}`);

    // Create system message to notify about reassignment
    const { adminDb } = await import('../admin-db');
    const advisor = adminDb.getUserById(lastAdvisorId);
    const advisorName = advisor?.username || lastAdvisorId;

    crmDb.appendMessage({
      convId: conversation.id,
      direction: "outgoing",
      type: "system",
      text: `üîÑ Cliente recurrente - Re-asignado autom√°ticamente a: ${advisorName}`,
      mediaUrl: null,
      mediaThumb: null,
      repliedToId: null,
      status: "sent",
    });
  }

  // Check bot timeout - if bot has been active longer than configured timeout, transfer to fallback queue
  if (conversation.botStartedAt && conversation.botFlowId) {
    const { LocalStorageFlowProvider } = await import('../flow-provider');
    const flowProvider = new LocalStorageFlowProvider();
    const flowConfig = await flowProvider.getFlow(conversation.botFlowId) as any;

    // Check if flow exists before accessing properties
    if (!flowConfig) {
      logDebug(`[CRM] ‚ö†Ô∏è Flow ${conversation.botFlowId} not found - skipping bot timeout check`);
    } else {
      const botTimeout = flowConfig.botTimeout; // in minutes
      const fallbackQueue = flowConfig.fallbackQueue;

    if (botTimeout && fallbackQueue) {
      const botDuration = (Date.now() - conversation.botStartedAt) / 1000 / 60; // in minutes
      if (botDuration >= botTimeout) {
        logDebug(`[CRM] Bot timeout exceeded (${botDuration.toFixed(1)}/${botTimeout} min) - transferring to fallback queue`);

        // Transfer to fallback queue
        crmDb.updateConversationMeta(conversation.id, {
          queueId: fallbackQueue,
          botStartedAt: null, // Clear bot tracking
          botFlowId: null,
        });

        // Create system message
        const { adminDb } = await import('../admin-db');
        const queue = adminDb.getQueueById(fallbackQueue);
        const queueName = queue?.name || fallbackQueue;

        crmDb.appendMessage({
          convId: conversation.id,
          direction: "outgoing",
          type: "system",
          text: `‚è±Ô∏è Tiempo m√°ximo con bot excedido (${botTimeout} min) - Transferido a cola: ${queueName}`,
          mediaUrl: null,
          mediaThumb: null,
          repliedToId: null,
          status: "sent",
        });

        // Try to auto-assign to available advisor in fallback queue
        if (queue && queue.assignedAdvisors.length > 0) {
          const { advisorPresenceTracker } = await import('../crm/presence');
          for (const advisorId of queue.assignedAdvisors) {
            const statusAssignment = adminDb.getAdvisorStatus(advisorId);
            if (statusAssignment) {
              const status = adminDb.getAdvisorStatusById(statusAssignment.statusId);
              const presence = advisorPresenceTracker.getPresence(advisorId);
              if (presence?.isOnline && status?.action === "accept") {
                crmDb.assignConversation(conversation.id, advisorId);
                const user = adminDb.getUserById(advisorId);
                const advisorName = user?.username || advisorId;
                logDebug(`[CRM] Auto-assigned to ${advisorName} from fallback queue after bot timeout`);

                await crmDb.appendMessage({
                  convId: conversation.id,
                  direction: "outgoing",
                  type: "system",
                  text: `üéØ Asignado autom√°ticamente a: ${advisorName}`,
                  mediaUrl: null,
                  mediaThumb: null,
                  repliedToId: null,
                  status: "sent",
                });
                break;
              }
            }
          }
        }

        // Refresh conversation after updates
        conversation = (await crmDb.getConversationByIdAsync(conversation.id))!;
      }
    }
    }
  }

  const { type, text, attachment } = await translateMessage(args.message);

  // Find the message being replied to (if any)
  let repliedToId: string | null = null;
  if (args.message.context?.id) {
    const whatsappReplyToId = args.message.context.id;
    logDebug(`[CRM] Message is a reply to WhatsApp message ID: ${whatsappReplyToId}`);

    // Search for the message with this whatsapp_message_id in providerMetadata
    const allMessages = await crmDb.listMessages(conversation.id); // Get all messages for conversation
    const originalMessage = allMessages.find(msg =>
      msg.providerMetadata &&
      (msg.providerMetadata as any).whatsapp_message_id === whatsappReplyToId
    );

    if (originalMessage) {
      repliedToId = originalMessage.id;
      logDebug(`[CRM] Found original message: ${originalMessage.id}`);
    } else {
      logDebug(`[CRM] Could not find original message with WhatsApp ID: ${whatsappReplyToId}`);
    }
  }

  const storedMessage = await crmDb.appendMessage({
    convId: conversation.id,
    direction: "incoming",
    type,
    text,
    mediaUrl: attachment?.url ?? null,
    mediaThumb: attachment?.thumbUrl ?? null,
    repliedToId,
    status: "delivered",
    providerMetadata: {
      whatsapp_message_id: args.message.id,
      from: args.message.from,
      timestamp: args.message.timestamp,
    },
  });

  // Track incoming message for metrics
  metricsTracker.recordMessage(conversation.id, false);

  let storedAttachment: Attachment | null = null;
  if (attachment) {
    storedAttachment = crmDb.storeAttachment({
      id: attachment.id,
      msgId: storedMessage.id,
      filename: attachment.filename,
      mime: attachment.mime,
      size: attachment.size,
      url: attachment.url,
      thumbUrl: attachment.thumbUrl,
    });
  }

  args.socketManager.emitNewMessage({ message: storedMessage, attachment: storedAttachment });
  const refreshed = crmDb.getConversationById(conversation.id);
  if (refreshed) {
    args.socketManager.emitConversationUpdate({ conversation: refreshed });
  }

  // NO CREAR AUTOM√ÅTICAMENTE - Solo buscar contacto existente en Bitrix24
  if (!conversation.bitrixId && args.bitrixService.isAvailable) {
    args.bitrixService
      .lookupByPhone(phone)
      .then((contact) => {
        if (contact?.ID) {
          // Encontr√≥ contacto existente, asociarlo CON sus datos (nombre incluido)
          args.bitrixService.attachConversation(conversation!, contact.ID.toString(), contact);
          const updated = crmDb.getConversationById(conversation.id);
          if (updated) {
            args.socketManager.emitConversationUpdate({ conversation: updated });
          }
          const fullName = `${contact.NAME || ''} ${contact.LAST_NAME || ''}`.trim();
          console.log(`[CRM][Bitrix] Contacto existente encontrado: ${contact.ID} (${fullName || 'Sin nombre'}) para ${phone}`);
        } else {
          // No hay contacto en Bitrix, se mostrar√° solo con datos de Meta (phone + profileName)
          console.log(`[CRM][Bitrix] No se encontr√≥ contacto para ${phone}. Mostrando solo datos de Meta.`);
        }
      })
      .catch((error) => {
        console.warn("[CRM][Bitrix] lookup failed", error);
      });
  }
}

async function translateMessage(message: WhatsAppMessage): Promise<{
  type: MessageType;
  text: string | null;
  attachment: Attachment | null;
}> {
  switch (message.type) {
    case "text":
      return { type: "text", text: message.text?.body ?? null, attachment: null };
    case "interactive": {
      const reply = message.interactive?.button_reply ?? message.interactive?.list_reply;
      return {
        type: "text",
        text: reply?.title ?? "",
        attachment: null,
      };
    }
    case "button":
      return { type: "text", text: message.button?.text ?? message.button?.payload ?? "", attachment: null };
    case "image":
    case "video":
    case "audio":
    case "document":
    case "sticker": {
      const mediaInfo = getMediaInfo(message);
      if (!mediaInfo) {
        logError(`[CRM][Media] No se pudo extraer info de media del mensaje tipo ${message.type}`);
        return { type: "document", text: null, attachment: null };
      }
      logDebug(`[CRM][Media] Descargando ${message.type} con ID: ${mediaInfo.id} (usando axios)`);
      const downloaded = await downloadMedia(mediaInfo.id, mediaInfo.mimeType ?? undefined);
      if (!downloaded) {
        logError(`[CRM][Media] Fall√≥ descarga de ${message.type} con ID: ${mediaInfo.id}`);
        return {
          type: mapType(message.type),
          text: mediaInfo.caption ?? null,
          attachment: null,
        };
      }
      logDebug(`[CRM][Media] Descarga exitosa: ${downloaded.filename} (${downloaded.mime}, ${downloaded.buffer.length} bytes)`);
      const stored = await attachmentStorage.saveBuffer({
        buffer: downloaded.buffer,
        filename: downloaded.filename,
        mime: downloaded.mime,
      });
      logDebug(`[CRM][Media] Guardado en storage: ${stored.url}`);
      return {
        type: mapType(message.type),
        text: mediaInfo.caption ?? null,
        attachment: {
          id: stored.id,
          msgId: null,
          filename: downloaded.filename,
          mime: downloaded.mime,
          size: stored.size,
          url: stored.url,
          thumbUrl: stored.url,
          createdAt: Date.now(),
        },
      };
    }
    default:
      return { type: "system", text: null, attachment: null };
  }
}

function mapType(type: WhatsAppMessage["type"]): MessageType {
  switch (type) {
    case "image":
      return "image";
    case "video":
      return "video";
    case "audio":
      return "audio";
    case "document":
      return "document";
    case "sticker":
      return "sticker";
    default:
      return "text";
  }
}

function getMediaInfo(message: WhatsAppMessage):
  | { id: string; mimeType?: string; caption?: string }
  | null {
  switch (message.type) {
    case "image":
      return { id: message.image?.id ?? "", mimeType: message.image?.mime_type, caption: message.image?.caption ?? undefined };
    case "video":
      return { id: message.video?.id ?? "", mimeType: message.video?.mime_type, caption: message.video?.caption ?? undefined };
    case "audio":
      return { id: message.audio?.id ?? "", mimeType: message.audio?.mime_type };
    case "document":
      return { id: message.document?.id ?? "", mimeType: message.document?.mime_type, caption: message.document?.caption ?? undefined };
    case "sticker":
      return { id: message.sticker?.id ?? "", mimeType: message.sticker?.mime_type };
    default:
      return null;
  }
}

async function downloadMedia(mediaId: string, mimeHint?: string): Promise<{ buffer: Buffer; filename: string; mime: string } | null> {
  if (!mediaId) {
    logError("[CRM][Media] downloadMedia: mediaId vac√≠o");
    return null;
  }
  const whatsappEnv = getWhatsAppEnv();
  if (!whatsappEnv.accessToken) {
    logError("[CRM][Media] downloadMedia: WHATSAPP_ACCESS_TOKEN no configurado");
    return null;
  }

  // USAR CLOUDFLARE WORKER para descargar media (m√°s confiable)
  const workerUrl = "https://rapid-surf-b867.cpalomino.workers.dev/download";
  logDebug(`[CRM][Media] Descargando desde Cloudflare Worker: ${mediaId}`);

  try {
    const workerResponse = await axios.post(workerUrl, {
      mediaId: mediaId,
      accessToken: whatsappEnv.accessToken,
      apiVersion: whatsappEnv.apiVersion || "v20.0"
    }, {
      responseType: "arraybuffer",
      timeout: 30000, // 30 segundos
    });

    const buffer = Buffer.from(workerResponse.data);
    const mime = workerResponse.headers['content-type'] || mimeHint || "application/octet-stream";
    const filename = `${mediaId}`;

    logDebug(`[CRM][Media] ‚úÖ Descarga exitosa desde Cloudflare: ${buffer.length} bytes`);
    return { buffer, filename, mime };
  } catch (error) {
    if (axios.isAxiosError(error)) {
      logError(`[CRM][Media] Cloudflare Worker error: HTTP ${error.response?.status}`, error.response?.data);
    } else {
      logError("[CRM][Media] Error descargando desde Cloudflare Worker", error);
    }
    return null;
  }
}
