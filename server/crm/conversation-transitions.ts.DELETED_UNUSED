/**
 * Safe Conversation Status Transitions
 *
 * BLINDAJE: Wrapper functions that validate state changes before applying them
 */

import { ConversationStatus, validateStatusChange } from './conversation-status';
import type { PostgresCRM } from './db-postgres';

/**
 * Error class for invalid status transitions
 */
export class InvalidStatusTransitionError extends Error {
  constructor(
    public currentStatus: string,
    public targetStatus: string,
    message: string
  ) {
    super(message);
    this.name = 'InvalidStatusTransitionError';
  }
}

/**
 * Safe wrapper for status changes with validation
 */
export class ConversationStatusManager {
  constructor(private db: PostgresCRM) {}

  /**
   * Safely transition conversation to new status
   * Throws error if transition is invalid
   */
  async transitionTo(
    conversationId: string,
    newStatus: ConversationStatus,
    metadata?: {
      reason?: string;
      userId?: string;
      botFlowId?: string;
      queueId?: string;
    }
  ): Promise<void> {
    // Get current conversation
    const conversation = await this.db.getConversationById(conversationId);

    if (!conversation) {
      throw new Error(`Conversation ${conversationId} not found`);
    }

    // Validate transition
    const validation = validateStatusChange(conversation.status, newStatus);

    if (!validation.valid) {
      const error = new InvalidStatusTransitionError(
        conversation.status,
        newStatus,
        validation.error || 'Invalid transition'
      );

      console.error(
        `[StatusManager] ❌ Invalid transition for ${conversationId}: ${error.message}`,
        { currentStatus: conversation.status, targetStatus: newStatus, metadata }
      );

      throw error;
    }

    // Log transition
    console.log(
      `[StatusManager] ✅ Transitioning conversation ${conversationId}: ${conversation.status} → ${newStatus}`,
      metadata
    );

    // Apply status change
    await this.db.updateConversationMeta(conversationId, {
      status: newStatus,
      ...this.getMetadataForTransition(conversation.status, newStatus, metadata),
    });
  }

  /**
   * Get additional metadata to update based on transition type
   */
  private getMetadataForTransition(
    from: string,
    to: string,
    metadata?: {
      reason?: string;
      userId?: string;
      botFlowId?: string;
      queueId?: string;
    }
  ): Record<string, any> {
    const updates: Record<string, any> = {};

    // ARCHIVED or CLOSED: Clear assignment data
    if (to === ConversationStatus.ARCHIVED || to === ConversationStatus.CLOSED) {
      updates.assignedTo = null;
      updates.assignedAt = null;
      updates.activeAdvisors = [];
      updates.transferredFrom = null;
      updates.transferredAt = null;
      updates.queueId = null;
      updates.botStartedAt = null;
      updates.botFlowId = null;
    }

    // ACTIVE: May set bot or queue
    if (to === ConversationStatus.ACTIVE) {
      if (metadata?.botFlowId) {
        updates.botFlowId = metadata.botFlowId;
        updates.botStartedAt = Date.now();
      }
      if (metadata?.queueId) {
        updates.queueId = metadata.queueId;
        updates.queuedAt = Date.now();
      }
    }

    // ATTENDING: Set advisor and clear queue
    if (to === ConversationStatus.ATTENDING && metadata?.userId) {
      updates.assignedTo = metadata.userId;
      updates.assignedAt = Date.now();
      updates.queueId = null; // ✅ Clear queue when advisor accepts
      updates.queuedAt = null;
    }

    return updates;
  }

  /**
   * Close conversation (manual close or campaign)
   */
  async close(
    conversationId: string,
    reason: 'manual' | 'campaign' | 'bot_timeout',
    userId?: string
  ): Promise<void> {
    await this.transitionTo(conversationId, ConversationStatus.CLOSED, {
      reason,
      userId,
    });
  }

  /**
   * Archive conversation (auto-archive for inactivity)
   */
  async archive(conversationId: string, reason: string = 'auto_inactivity'): Promise<void> {
    await this.transitionTo(conversationId, ConversationStatus.ARCHIVED, {
      reason,
    });
  }

  /**
   * Reopen conversation (client writes back)
   */
  async reopen(
    conversationId: string,
    activateBot?: string,
    assignToQueue?: string
  ): Promise<void> {
    await this.transitionTo(conversationId, ConversationStatus.ACTIVE, {
      reason: 'client_response',
      botFlowId: activateBot,
      queueId: assignToQueue,
    });
  }

  /**
   * Assign to advisor
   */
  async assignToAdvisor(conversationId: string, advisorId: string): Promise<void> {
    await this.transitionTo(conversationId, ConversationStatus.ATTENDING, {
      reason: 'advisor_assignment',
      userId: advisorId,
    });
  }

  /**
   * Unassign from advisor (back to queue)
   */
  async unassignFromAdvisor(conversationId: string, queueId?: string): Promise<void> {
    await this.transitionTo(conversationId, ConversationStatus.ACTIVE, {
      reason: 'advisor_unassignment',
      queueId,
    });
  }
}
