/**
 * Bounce Service - Automatic message bouncing between advisors in queue
 *
 * When a message in NUEVOS MENSAJES is not accepted by an advisor within X minutes,
 * it automatically "bounces" to another advisor in the same queue.
 */

import { Pool } from 'pg';
import type { Conversation } from './models';
import { roundRobinTracker } from './round-robin-tracker';

interface BounceConfig {
  enabled: boolean;
  bounceTimeMinutes: number;  // Tiempo m√°ximo sin aceptar antes de rebotar
  maxBounces: number;          // N√∫mero m√°ximo de rebotes permitidos
  strategy: 'round-robin' | 'least-busy' | 'random';
}

const DEFAULT_BOUNCE_CONFIG: BounceConfig = {
  enabled: true,
  bounceTimeMinutes: 10,
  maxBounces: 5,
  strategy: 'round-robin'
};

export class BounceService {
  private pool: Pool;
  private config: BounceConfig = DEFAULT_BOUNCE_CONFIG;
  private intervalId: NodeJS.Timeout | null = null;

  constructor() {
    this.pool = new Pool({
      user: process.env.POSTGRES_USER || 'whatsapp_user',
      host: process.env.POSTGRES_HOST || 'localhost',
      database: process.env.POSTGRES_DB || 'flowbuilder_crm',
      password: process.env.POSTGRES_PASSWORD || 'azaleia_pg_2025_secure',
      port: parseInt(process.env.POSTGRES_PORT || '5432'),
      max: 10,
    });

    this.loadConfig();
  }

  /**
   * Load bounce configuration from database
   */
  private async loadConfig(): Promise<void> {
    try {
      const result = await this.pool.query(
        `SELECT value FROM system_settings WHERE key = 'bounce_config'`
      );

      if (result.rows.length > 0) {
        this.config = { ...DEFAULT_BOUNCE_CONFIG, ...result.rows[0].value };
      }
    } catch (error) {
      console.error('[BounceService] Error loading config:', error);
    }
  }

  /**
   * Save bounce configuration to database
   */
  async saveConfig(config: Partial<BounceConfig>): Promise<void> {
    this.config = { ...this.config, ...config };

    try {
      await this.pool.query(`
        INSERT INTO system_settings (key, value, updated_at)
        VALUES ('bounce_config', $1, $2)
        ON CONFLICT (key) DO UPDATE SET value = $1, updated_at = $2
      `, [JSON.stringify(this.config), Date.now()]);

      console.log('[BounceService] ‚úÖ Config saved:', this.config);
    } catch (error) {
      console.error('[BounceService] Error saving config:', error);
      throw error;
    }
  }

  /**
   * Get current bounce configuration
   */
  async getConfig(): Promise<BounceConfig> {
    await this.loadConfig();
    return this.config;
  }

  /**
   * Start the bounce checker interval
   */
  start(): void {
    if (this.intervalId) {
      console.log('[BounceService] Already running');
      return;
    }

    // Check every minute
    this.intervalId = setInterval(() => {
      this.checkAndBounce();
    }, 60 * 1000);

    console.log('[BounceService] üöÄ Started (checking every 1 minute)');
  }

  /**
   * Stop the bounce checker interval
   */
  stop(): void {
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = null;
      console.log('[BounceService] ‚èπÔ∏è  Stopped');
    }
  }

  /**
   * Check for conversations that need to bounce and bounce them
   */
  private async checkAndBounce(): Promise<void> {
    if (!this.config.enabled) {
      return;
    }

    try {
      const bounceTimeMs = this.config.bounceTimeMinutes * 60 * 1000;
      const now = Date.now();
      const cutoffTime = now - bounceTimeMs;

      // Find conversations in queue that:
      // 1. Have queue_id (in queue)
      // 2. Are assigned to an advisor (assigned_to_advisor)
      // 3. Haven't been accepted (status = 'active', not 'attending')
      // 4. Assigned time is older than cutoff
      // 5. Haven't exceeded max bounces
      const result = await this.pool.query(`
        SELECT id, queue_id, assigned_to_advisor, assigned_to_advisor_at, bounce_count
        FROM crm_conversations
        WHERE status = 'active'
          AND queue_id IS NOT NULL
          AND assigned_to_advisor IS NOT NULL
          AND assigned_to_advisor_at < $1
          AND bounce_count < $2
      `, [cutoffTime, this.config.maxBounces]);

      if (result.rows.length === 0) {
        return;
      }

      console.log(`[BounceService] üîÑ Found ${result.rows.length} conversations to bounce`);

      for (const row of result.rows) {
        await this.bounceConversation(row.id, row.queue_id, row.assigned_to_advisor);
      }
    } catch (error) {
      console.error('[BounceService] Error in checkAndBounce:', error);
    }
  }

  /**
   * Bounce a conversation to another advisor in the same queue
   */
  private async bounceConversation(
    conversationId: string,
    queueId: string,
    currentAdvisor: string
  ): Promise<void> {
    try {
      // Get all advisors in the queue (excluding current one)
      const advisorsResult = await this.pool.query(`
        SELECT user_id FROM queue_members
        WHERE queue_id = $1 AND user_id != $2
      `, [queueId, currentAdvisor]);

      if (advisorsResult.rows.length === 0) {
        console.log(`[BounceService] ‚ö†Ô∏è  No other advisors in queue ${queueId}, skipping bounce for conversation ${conversationId}`);
        return;
      }

      // Select next advisor based on strategy
      const nextAdvisor = await this.selectNextAdvisor(
        advisorsResult.rows.map(r => r.user_id),
        queueId
      );

      if (!nextAdvisor) {
        console.log(`[BounceService] ‚ö†Ô∏è  Could not select next advisor for conversation ${conversationId}`);
        return;
      }

      // Update conversation: assign to new advisor, increment bounce count
      const now = Date.now();
      await this.pool.query(`
        UPDATE crm_conversations
        SET assigned_to_advisor = $1,
            assigned_to_advisor_at = $2,
            bounce_count = bounce_count + 1,
            last_bounce_at = $2,
            updated_at = $2
        WHERE id = $3
      `, [nextAdvisor, now, conversationId]);

      console.log(`[BounceService] ‚úÖ Bounced conversation ${conversationId} from ${currentAdvisor} to ${nextAdvisor}`);
    } catch (error) {
      console.error(`[BounceService] Error bouncing conversation ${conversationId}:`, error);
    }
  }

  /**
   * Select next advisor based on strategy
   */
  private async selectNextAdvisor(
    availableAdvisors: string[],
    queueId: string
  ): Promise<string | null> {
    if (availableAdvisors.length === 0) return null;

    switch (this.config.strategy) {
      case 'random':
        return availableAdvisors[Math.floor(Math.random() * availableAdvisors.length)];

      case 'least-busy':
        return await this.getLeastBusyAdvisor(availableAdvisors);

      case 'round-robin':
      default:
        // Use round-robin tracker for fair distribution
        return roundRobinTracker.getNextAdvisor(queueId, availableAdvisors);
    }
  }

  /**
   * Get the advisor with least active conversations
   */
  private async getLeastBusyAdvisor(advisorIds: string[]): Promise<string | null> {
    try {
      const result = await this.pool.query(`
        SELECT assigned_to_advisor, COUNT(*) as count
        FROM crm_conversations
        WHERE assigned_to_advisor = ANY($1)
          AND status IN ('active', 'attending')
        GROUP BY assigned_to_advisor
        ORDER BY count ASC
        LIMIT 1
      `, [advisorIds]);

      if (result.rows.length > 0) {
        return result.rows[0].assigned_to_advisor;
      }

      // If no advisor has conversations, return first one
      return advisorIds[0];
    } catch (error) {
      console.error('[BounceService] Error getting least busy advisor:', error);
      return advisorIds[0];
    }
  }

  /**
   * Manually assign a conversation to an advisor (when bot transfers to queue)
   */
  async assignToAdvisor(conversationId: string, queueId: string): Promise<void> {
    try {
      // Get all advisors in the queue
      const advisorsResult = await this.pool.query(`
        SELECT user_id FROM queue_members WHERE queue_id = $1
      `, [queueId]);

      if (advisorsResult.rows.length === 0) {
        console.log(`[BounceService] ‚ö†Ô∏è  No advisors in queue ${queueId}, cannot assign conversation ${conversationId}`);
        return;
      }

      const advisorIds = advisorsResult.rows.map(r => r.user_id);
      const selectedAdvisor = await this.selectNextAdvisor(advisorIds, queueId);

      if (!selectedAdvisor) {
        console.log(`[BounceService] ‚ö†Ô∏è  Could not select advisor for conversation ${conversationId}`);
        return;
      }

      const now = Date.now();
      await this.pool.query(`
        UPDATE crm_conversations
        SET assigned_to_advisor = $1,
            assigned_to_advisor_at = $2,
            bounce_count = 0,
            updated_at = $2
        WHERE id = $3
      `, [selectedAdvisor, now, conversationId]);

      console.log(`[BounceService] ‚úÖ Assigned conversation ${conversationId} to advisor ${selectedAdvisor} in queue ${queueId}`);
    } catch (error) {
      console.error(`[BounceService] Error assigning conversation ${conversationId}:`, error);
    }
  }

  /**
   * Clear bounce assignment when advisor accepts conversation
   */
  async clearBounceData(conversationId: string): Promise<void> {
    try {
      await this.pool.query(`
        UPDATE crm_conversations
        SET assigned_to_advisor = NULL,
            assigned_to_advisor_at = NULL,
            updated_at = $1
        WHERE id = $2
      `, [Date.now(), conversationId]);

      console.log(`[BounceService] ‚úÖ Cleared bounce data for conversation ${conversationId}`);
    } catch (error) {
      console.error(`[BounceService] Error clearing bounce data for ${conversationId}:`, error);
    }
  }
}

// Singleton instance
export const bounceService = new BounceService();
